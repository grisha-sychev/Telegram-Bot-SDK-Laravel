<?php

namespace App\Console\Commands;

use Illuminate\Console\Command;
use Illuminate\Support\Facades\Http;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\Storage;
use App\Models\Bot;

class HealthCommand extends Command
{
    protected $signature = 'bot:health {--bot= : –ò–º—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –±–æ—Ç–∞ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏} {--no-ssl : –û—Ç–∫–ª—é—á–∏—Ç—å –ø—Ä–æ–≤–µ—Ä–∫—É SSL —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç–æ–≤} {--verbose-errors : –ü–æ–∫–∞–∑–∞—Ç—å –ø–æ–¥—Ä–æ–±–Ω—ã–µ –æ—à–∏–±–∫–∏ –∏–∑ –ª–æ–≥–æ–≤}';
    protected $description = '–ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è –±–æ—Ç–æ–≤';

    public function handle()
    {
        $this->info('üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ—Å—Ç–æ—è–Ω–∏—è –±–æ—Ç–æ–≤');
        $this->newLine();

        // –ò–Ω—Ç–µ—Ä–∞–∫—Ç–∏–≤–Ω–æ–µ –º–µ–Ω—é –µ—Å–ª–∏ –∫–æ–º–∞–Ω–¥–∞ –∑–∞–ø—É—â–µ–Ω–∞ –±–µ–∑ –æ–ø—Ü–∏–π
        $botName = $this->option('bot');
        $noSsl = $this->option('no-ssl');
        $verboseErrors = $this->option('verbose-errors');
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –±—ã–ª–∏ –ª–∏ –ø–µ—Ä–µ–¥–∞–Ω—ã –∫–∞–∫–∏–µ-–ª–∏–±–æ –æ–ø—Ü–∏–∏
        $hasOptionsProvided = count(array_filter($this->options())) > 0;
        
        if (!$hasOptionsProvided && $this->input->isInteractive()) {
            $options = $this->collectHealthOptions();
            $botName = $options['bot_name'];
            $noSsl = $options['no_ssl'];
            $verboseErrors = $options['verbose_errors'];
        }
        
        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –∏—Å–ø–æ–ª—å–∑—É–µ–º—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
        if ($botName) {
            $this->line('  üéØ –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –±–æ—Ç–∞: ' . $botName);
        } else {
            $this->line('  üéØ –ü—Ä–æ–≤–µ—Ä–∫–∞ –≤—Å–µ—Ö –±–æ—Ç–æ–≤');
        }
        if ($noSsl) {
            $this->warn('  ‚ö†Ô∏è  SSL –ø—Ä–æ–≤–µ—Ä–∫–∞ –æ—Ç–∫–ª—é—á–µ–Ω–∞');
        }
        if ($verboseErrors) {
            $this->line('  üîç –ü–æ–¥—Ä–æ–±–Ω—ã–µ –æ—à–∏–±–∫–∏: –í–ö–õ–Æ–ß–ï–ù–´');
        }
        $this->newLine();

        // –ü–æ–ª—É—á–∞–µ–º –±–æ—Ç–æ–≤ –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
        try {
            if ($botName) {
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –±–æ—Ç–∞
                $bot = Bot::byName($botName)->first();
                if (!$bot) {
                    $this->error("‚ùå –ë–æ—Ç '{$botName}' –Ω–µ –Ω–∞–π–¥–µ–Ω");
                    $this->line('üí° –î–æ—Å—Ç—É–ø–Ω—ã–µ –±–æ—Ç—ã:');
                    $availableBots = Bot::pluck('name')->toArray();
                    if (empty($availableBots)) {
                        $this->line('   (–Ω–µ—Ç –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –±–æ—Ç–æ–≤)');
                    } else {
                        foreach ($availableBots as $name) {
                            $this->line("   - {$name}");
                        }
                    }
                    return 1;
                }
                
                $this->info("ü§ñ –ü—Ä–æ–≤–µ—Ä–∫–∞ –±–æ—Ç–∞: {$bot->name}");
                $this->newLine();
                $this->checkBot($bot, $noSsl, $verboseErrors);
                $this->newLine();
            } else {
                // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—Å–µ—Ö –±–æ—Ç–æ–≤
                $bots = Bot::all();
                
                if ($bots->isEmpty()) {
                    $this->warn('‚ö†Ô∏è  –ù–µ—Ç –∑–∞—Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö –±–æ—Ç–æ–≤');
                    $this->line('üí° –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ –∫–æ–º–∞–Ω–¥—É: php artisan bot:new');
                    $this->newLine();
                } else {
                    $this->info("ü§ñ –ù–∞–π–¥–µ–Ω–æ –±–æ—Ç–æ–≤: {$bots->count()}");
                    $this->newLine();

                    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–∞–∂–¥–æ–≥–æ –±–æ—Ç–∞
                    foreach ($bots as $bot) {
                        $this->checkBot($bot, $noSsl, $verboseErrors);
                        $this->newLine();
                    }
                }
            }
        } catch (\Exception $e) {
            $this->error('‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö: ' . $e->getMessage());
            $this->warn('üí° –£–±–µ–¥–∏—Ç–µ—Å—å —á—Ç–æ –∑–∞–ø—É—â–µ–Ω—ã –º–∏–≥—Ä–∞—Ü–∏–∏: php artisan migrate');
            return 1;
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é —Å–∏—Å—Ç–µ–º—ã
        $this->checkConfiguration();

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ö—Ä–∞–Ω–∏–ª–∏—â–µ
        $this->checkStorage();

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å–æ—Å—Ç–æ—è–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã
        $this->checkSystemHealth();

        $this->newLine();
        $this->info('‚úÖ –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞');

        return 0;
    }

    private function collectHealthOptions(): array
    {
        $this->info('‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –ø—Ä–æ–≤–µ—Ä–∫–∏ (–æ–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ)');
        $this->newLine();

        // –ü–æ–ª—É—á–∞–µ–º —Å–ø–∏—Å–æ–∫ –±–æ—Ç–æ–≤ –¥–ª—è –≤—ã–±–æ—Ä–∞
        try {
            $bots = Bot::pluck('name')->toArray();
        } catch (\Exception $e) {
            $this->error('‚ùå –û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞ –±–æ—Ç–æ–≤: ' . $e->getMessage());
            return [
                'bot_name' => null,
                'no_ssl' => false,
            ];
        }

        // –í—ã–±–æ—Ä –±–æ—Ç–∞
        $botName = null;
        if (!empty($bots)) {
            $choices = array_merge(['–í—Å–µ –±–æ—Ç—ã'], $bots);
            $choice = $this->choice('–ö–∞–∫–æ–≥–æ –±–æ—Ç–∞ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å?', $choices, 0);
            
            if ($choice !== '–í—Å–µ –±–æ—Ç—ã') {
                $botName = $choice;
            }
        }

        // –ù–∞—Å—Ç—Ä–æ–π–∫–∏ SSL
        $noSsl = $this->confirm('–û—Ç–∫–ª—é—á–∏—Ç—å –ø—Ä–æ–≤–µ—Ä–∫—É SSL —Å–µ—Ä—Ç–∏—Ñ–∏–∫–∞—Ç–æ–≤? (—Ç–æ–ª—å–∫–æ –¥–ª—è —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏)', false);
        
        // –ü–æ–¥—Ä–æ–±–Ω—ã–µ –æ—à–∏–±–∫–∏
        $verboseErrors = $this->confirm('–ü–æ–∫–∞–∑–∞—Ç—å –ø–æ–¥—Ä–æ–±–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –æ—à–∏–±–æ–∫ –∏–∑ –ª–æ–≥–æ–≤?', false);

        $this->newLine();

        return [
            'bot_name' => $botName,
            'no_ssl' => $noSsl,
            'verbose_errors' => $verboseErrors,
        ];
    }

    private function checkBot(Bot $bot, bool $noSsl = false, bool $verboseErrors = false): void
    {
        $statusIcon = $bot->enabled ? 'üü¢' : 'üî¥';
        $status = $bot->enabled ? '–∞–∫—Ç–∏–≤–µ–Ω' : '–æ—Ç–∫–ª—é—á–µ–Ω';
        
        $this->line("{$statusIcon} –ë–æ—Ç: {$bot->name} (@{$bot->username}) - {$status}");
        $this->line("  üìù –ò–º—è: {$bot->first_name}");
        $this->line("  üÜî ID: {$bot->bot_id}");
        
        if (!$bot->enabled) {
            $this->warn("  ‚ö†Ô∏è  –ë–æ—Ç –æ—Ç–∫–ª—é—á–µ–Ω");
            return;
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º API —Å–≤—è–∑–Ω–æ—Å—Ç—å  
        $apiStatus = $this->checkTelegramAPI($bot->token, $noSsl);
        if ($apiStatus['status'] === 'ok') {
            $this->line("  ‚úÖ API: –°–æ–µ–¥–∏–Ω–µ–Ω–∏–µ OK");
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–ª–∞—Å—Å –±–æ—Ç–∞
            if ($bot->botClassExists()) {
                $this->line("  ‚úÖ –ö–ª–∞—Å—Å: {$bot->getBotClass()}");
            } else {
                $this->warn("  ‚ö†Ô∏è  –ö–ª–∞—Å—Å –±–æ—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω: {$bot->getBotClass()}");
            }
        } else {
            $this->error("  ‚ùå API: {$apiStatus['message']}");
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º webhook
        $this->checkBotWebhook($bot, $noSsl);
        
        // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–æ–¥—Ä–æ–±–Ω—ã–µ –æ—à–∏–±–∫–∏ –µ—Å–ª–∏ –∑–∞–ø—Ä–æ—à–µ–Ω–æ
        if ($verboseErrors) {
            $this->showDetailedErrors($bot, $noSsl);
        }
    }

    private function checkTelegramAPI(string $token, bool $noSsl = false): array
    {
        try {
            $http = Http::timeout(10);
            
            if ($noSsl) {
                $http = $http->withOptions([
                    'verify' => false,
                    'curl' => [
                        CURLOPT_SSL_VERIFYPEER => false,
                        CURLOPT_SSL_VERIFYHOST => false,
                    ]
                ]);
            }
            
            $response = $http->get("https://api.telegram.org/bot{$token}/getMe");
            
            if ($response->successful()) {
                $botInfo = $response->json()['result'];
                return [
                    'status' => 'ok',
                    'bot_info' => $botInfo,
                ];
            }
            
            return [
                'status' => 'error',
                'message' => 'API returned: ' . $response->status(),
            ];
        } catch (\Exception $e) {
            return [
                'status' => 'error',
                'message' => $e->getMessage(),
            ];
        }
    }

    private function checkBotWebhook(Bot $bot, bool $noSsl = false): void
    {
        try {
            $http = Http::timeout(10);
            
            if ($noSsl) {
                $http = $http->withOptions([
                    'verify' => false,
                    'curl' => [
                        CURLOPT_SSL_VERIFYPEER => false,
                        CURLOPT_SSL_VERIFYHOST => false,
                    ]
                ]);
            }
            
            $response = $http->get("https://api.telegram.org/bot{$bot->token}/getWebhookInfo");
            
            if ($response->successful()) {
                $webhook = $response->json()['result'];
                
                if ($webhook['url']) {
                    $this->line("  üåê Webhook: {$webhook['url']}");
                    
                    if ($webhook['pending_update_count'] > 0) {
                        $this->warn("  ‚ö†Ô∏è  –û–∂–∏–¥–∞—é—Ç –æ–±—Ä–∞–±–æ—Ç–∫–∏: {$webhook['pending_update_count']} —Å–æ–æ–±—â–µ–Ω–∏–π");
                    } else {
                        $this->line("  ‚úÖ –ù–µ—Ç –æ–∂–∏–¥–∞—é—â–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π");
                    }
                    
                    if (!empty($webhook['last_error_message'])) {
                        $errorDate = date('Y-m-d H:i:s', $webhook['last_error_date']);
                        $this->error("  ‚ùå –ü–æ—Å–ª–µ–¥–Ω—è—è –æ—à–∏–±–∫–∞: {$errorDate} - {$webhook['last_error_message']}");
                    }
                } else {
                    $this->warn('  ‚ö†Ô∏è  Webhook –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω');
                }
            }
        } catch (\Exception $e) {
            $this->error("  ‚ùå –û—à–∏–±–∫–∞ –ø—Ä–æ–≤–µ—Ä–∫–∏ webhook: {$e->getMessage()}");
        }
    }



    private function checkConfiguration(): void
    {
        $this->info("üîß –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è —Å–∏—Å—Ç–µ–º—ã:");
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ–±—â–∏–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
        $logging = config('tegbot.logging.enabled', false);
        $this->line('  üìä –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ: ' . ($logging ? '–í–ö–õ–Æ–ß–ï–ù–û' : '–û–¢–ö–õ–Æ–ß–ï–ù–û'));

        $fileStorage = config('tegbot.files.download_path', storage_path('app/tegbot'));
        $this->line("  üìÅ –•—Ä–∞–Ω–∏–ª–∏—â–µ —Ñ–∞–π–ª–æ–≤: " . basename($fileStorage));

        $timeout = config('tegbot.api.timeout', 30);
        $this->line("  ‚è±Ô∏è  –¢–∞–π–º–∞—É—Ç API: {$timeout}s");

        $retries = config('tegbot.api.retries', 3);
        $this->line("  üîÑ –ü–æ–≤—Ç–æ—Ä—ã –ø—Ä–∏ –æ—à–∏–±–∫–∞—Ö: {$retries}");

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ
        $cacheEnabled = config('tegbot.cache.enabled', false);
        $cacheDriver = config('tegbot.cache.driver', 'file');
        $this->line("  üíæ –ö—ç—à–∏—Ä–æ–≤–∞–Ω–∏–µ: " . ($cacheEnabled ? "–í–ö–õ–Æ–ß–ï–ù–û ({$cacheDriver})" : '–û–¢–ö–õ–Æ–ß–ï–ù–û'));

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ—á–µ—Ä–µ–¥–∏
        $queueEnabled = config('tegbot.queue.enabled', false);
        $queueDriver = config('tegbot.queue.connection', 'sync');
        $this->line("  üöÄ –û—á–µ—Ä–µ–¥–∏: " . ($queueEnabled ? "–í–ö–õ–Æ–ß–ï–ù–û ({$queueDriver})" : '–û–¢–ö–õ–Æ–ß–ï–ù–û'));
        
        $this->newLine();
    }

    private function checkStorage(): void
    {
        $downloadPath = config('tegbot.files.download_path', storage_path('app/tegbot/downloads'));
        
        if (!is_dir($downloadPath)) {
            try {
                mkdir($downloadPath, 0755, true);
                $this->line('  ‚úÖ Storage directory created: ' . basename(dirname($downloadPath)));
            } catch (\Exception $e) {
                $this->error("  ‚ùå Cannot create storage directory: {$e->getMessage()}");
                return;
            }
        } else {
            $this->line('  ‚úÖ Storage directory exists: ' . basename(dirname($downloadPath)));
        }

        if (!is_writable($downloadPath)) {
            $this->error('  ‚ùå Storage directory is not writable');
        } else {
            $this->line('  ‚úÖ Storage directory is writable');
        }
    }

    private function checkSystemHealth(): void
    {
        $this->info('üè• –°–æ—Å—Ç–æ—è–Ω–∏–µ —Å–∏—Å—Ç–µ–º—ã:');

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–∞–º—è—Ç–∏
        $memoryUsage = memory_get_usage(true);
        $memoryLimit = $this->parseMemoryLimit(ini_get('memory_limit'));
        
        if ($memoryLimit > 0) {
            $percentage = round(($memoryUsage / $memoryLimit) * 100, 1);
            $this->line("  üíæ –ü–∞–º—è—Ç—å: " . $this->formatBytes($memoryUsage) . " / " . $this->formatBytes($memoryLimit) . " ({$percentage}%)");
            
            if ($percentage > 80) {
                $this->warn('  ‚ö†Ô∏è  –í—ã—Å–æ–∫–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –ø–∞–º—è—Ç–∏');
            }
        } else {
            $this->line("  üíæ –ü–∞–º—è—Ç—å: " . $this->formatBytes($memoryUsage) . " (–±–µ–∑ –ª–∏–º–∏—Ç–∞)");
        }

        // –ü—Ä–æ–≤–µ—Ä–∫–∞ Redis (–µ—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑—É–µ—Ç—Å—è)
        if (config('tegbot.cache.enabled') && config('tegbot.cache.driver') === 'redis') {
            try {
                Cache::store('redis')->put('tegbot_health_test', 'ok', 10);
                $test = Cache::store('redis')->get('tegbot_health_test');
                
                if ($test === 'ok') {
                    $this->line('  üî¥ Redis: –ü–æ–¥–∫–ª—é—á–µ–Ω');
                } else {
                    $this->warn('  ‚ö†Ô∏è  Redis: –ü—Ä–æ–±–ª–µ–º—ã —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è');
                }
            } catch (\Exception $e) {
                $this->error("  ‚ùå Redis: {$e->getMessage()}");
            }
        }

        // –ü–æ—Å–ª–µ–¥–Ω—è—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å (–µ—Å–ª–∏ –µ—Å—Ç—å –ª–æ–≥–∏)
        $this->checkLastActivity();
    }

    private function checkLastActivity(): void
    {
        $logPath = storage_path('logs/laravel.log');
        
        if (file_exists($logPath)) {
            $lastModified = filemtime($logPath);
            $timeDiff = time() - $lastModified;
            
            if ($timeDiff < 300) { // 5 –º–∏–Ω—É—Ç
                $this->line('  ‚ö° –ü–æ—Å–ª–µ–¥–Ω—è—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å: ' . $this->formatTimeDiff($timeDiff) . ' –Ω–∞–∑–∞–¥');
            } else {
                $this->warn('  ‚ö†Ô∏è  –ü–æ—Å–ª–µ–¥–Ω—è—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å: ' . $this->formatTimeDiff($timeDiff) . ' –Ω–∞–∑–∞–¥');
            }
        } else {
            $this->line('  üìù –õ–æ–≥–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤—É—é—Ç');
        }
    }

    private function parseMemoryLimit(string $limit): int
    {
        if ($limit === '-1') return 0;
        
        $limit = trim($limit);
        $bytes = (int) $limit;
        
        if (preg_match('/(\d+)(.)/', $limit, $matches)) {
            $bytes = (int) $matches[1];
            switch (strtoupper($matches[2])) {
                case 'G': $bytes *= 1024;
                case 'M': $bytes *= 1024;
                case 'K': $bytes *= 1024;
            }
        }
        
        return $bytes;
    }

    private function formatBytes(int $bytes): string
    {
        $units = ['B', 'KB', 'MB', 'GB'];
        $i = 0;
        
        while ($bytes >= 1024 && $i < count($units) - 1) {
            $bytes /= 1024;
            $i++;
        }
        
        return round($bytes, 1) . ' ' . $units[$i];
    }

    private function formatTimeDiff(int $seconds): string
    {
        if ($seconds < 60) {
            return "{$seconds} —Å–µ–∫";
        } elseif ($seconds < 3600) {
            $minutes = floor($seconds / 60);
            return "{$minutes} –º–∏–Ω";
        } else {
            $hours = floor($seconds / 3600);
            $minutes = floor(($seconds % 3600) / 60);
            return "{$hours}—á {$minutes}–º";
        }
    }

    private function showDetailedErrors(Bot $bot, bool $noSsl = false): void
    {
        $this->newLine();
        $this->info("üîç –ü–æ–¥—Ä–æ–±–Ω—ã–π –∞–Ω–∞–ª–∏–∑ –æ—à–∏–±–æ–∫ –¥–ª—è –±–æ—Ç–∞ '{$bot->name}':");
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ –æ—à–∏–±–∫–∏ –≤ –ª–æ–≥–∞—Ö
        $this->checkRecentLogs($bot);
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –±–æ—Ç–∞
        $this->checkBotSettings($bot);
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å webhook URL
        $this->testWebhookEndpoint($bot, $noSsl);
    }

    private function checkRecentLogs(Bot $bot): void
    {
        $logPath = storage_path('logs/laravel.log');
        
        if (!file_exists($logPath)) {
            $this->warn('  üìù –õ–æ–≥ —Ñ–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω');
            return;
        }
        
        $this->line('  üìù –ê–Ω–∞–ª–∏–∑ –ª–æ–≥–æ–≤ –∑–∞ –ø–æ—Å–ª–µ–¥–Ω–∏–µ 24 —á–∞—Å–∞...');
        
        try {
            $lines = file($logPath, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES);
            $botErrors = [];
            $count = 0;
            
            // –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ 1000 —Å—Ç—Ä–æ–∫
            $recentLines = array_slice($lines, -1000);
            
            foreach ($recentLines as $line) {
                if (strpos($line, $bot->name) !== false && 
                    (strpos($line, 'ERROR') !== false || strpos($line, 'WARN') !== false)) {
                    
                    $botErrors[] = $line;
                    $count++;
                    
                    if ($count >= 10) break; // –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –º–∞–∫—Å–∏–º—É–º 10 –æ—à–∏–±–æ–∫
                }
            }
            
            if (empty($botErrors)) {
                $this->line('    ‚úÖ –û—à–∏–±–æ–∫ –¥–ª—è —ç—Ç–æ–≥–æ –±–æ—Ç–∞ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ');
            } else {
                $this->warn("    ‚ö†Ô∏è  –ù–∞–π–¥–µ–Ω–æ –æ—à–∏–±–æ–∫: " . count($botErrors));
                foreach ($botErrors as $error) {
                    $this->line('    ' . trim($error));
                }
            }
            
        } catch (\Exception $e) {
            $this->error("    ‚ùå –û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è –ª–æ–≥–æ–≤: {$e->getMessage()}");
        }
    }

    private function checkBotSettings(Bot $bot): void
    {
        $this->line('  ‚öôÔ∏è  –ê–Ω–∞–ª–∏–∑ –Ω–∞—Å—Ç—Ä–æ–µ–∫ –±–æ—Ç–∞...');
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ SSL
        $settings = $bot->settings ?? [];
        if (isset($settings['no_ssl']) && $settings['no_ssl']) {
            $this->warn('    ‚ö†Ô∏è  SSL –ø—Ä–æ–≤–µ—Ä–∫–∞ –æ—Ç–∫–ª—é—á–µ–Ω–∞ –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö –±–æ—Ç–∞');
        }
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤
        if (empty($bot->admin_ids)) {
            $this->warn('    ‚ö†Ô∏è  –ù–µ —É–∫–∞–∑–∞–Ω—ã ID –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤');
        } else {
            $adminCount = count($bot->admin_ids);
            $this->line("    üë• –ê–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–æ–≤: {$adminCount}");
        }
        
        // –ü—Ä–æ–≤–µ—Ä—è–µ–º webhook secret
        if (empty($bot->webhook_secret)) {
            $this->warn('    ‚ö†Ô∏è  Webhook secret –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω');
        } else {
            $this->line('    üîê Webhook secret: —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω');
        }
    }

    private function testWebhookEndpoint(Bot $bot, bool $noSsl = false): void
    {
        if (empty($bot->webhook_url)) {
            $this->warn('  üåê Webhook URL –Ω–µ —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω');
            return;
        }
        
        $this->line('  üåê –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ webhook endpoint...');
        $this->line("    URL: {$bot->webhook_url}");
        
        try {
            // –î–µ–ª–∞–µ–º –ø—Ä–æ—Å—Ç–æ–π GET –∑–∞–ø—Ä–æ—Å –∫ webhook
            $http = \Illuminate\Support\Facades\Http::timeout(30);
            
            if ($noSsl) {
                $http = $http->withOptions([
                    'verify' => false,
                    'curl' => [
                        CURLOPT_SSL_VERIFYPEER => false,
                        CURLOPT_SSL_VERIFYHOST => false,
                    ]
                ]);
                $this->line('    ‚ö†Ô∏è  SSL –ø—Ä–æ–≤–µ—Ä–∫–∞ –æ—Ç–∫–ª—é—á–µ–Ω–∞ –¥–ª—è —Ç–µ—Å—Ç–∞');
            }
            
            $response = $http->get($bot->webhook_url);
            
            $this->line("    üì° HTTP —Å—Ç–∞—Ç—É—Å: {$response->status()}");
            
            if ($response->status() === 405) {
                $this->line('    ‚úÖ Endpoint –æ—Ç–≤–µ—á–∞–µ—Ç (405 –æ–∂–∏–¥–∞–µ–º –¥–ª—è GET –∑–∞–ø—Ä–æ—Å–∞)');
            } elseif ($response->status() >= 200 && $response->status() < 300) {
                $this->line('    ‚úÖ Endpoint –¥–æ—Å—Ç—É–ø–µ–Ω');
            } else {
                $this->warn("    ‚ö†Ô∏è  –ù–µ–æ–∂–∏–¥–∞–Ω–Ω—ã–π —Å—Ç–∞—Ç—É—Å: {$response->status()}");
            }
            
            // –ü—Ä–æ–≤–µ—Ä—è–µ–º –≤—Ä–µ–º—è –æ—Ç–≤–µ—Ç–∞
            $responseTime = $response->transferStats?->getTransferTime() * 1000;
            if ($responseTime) {
                $this->line("    ‚è±Ô∏è  –í—Ä–µ–º—è –æ—Ç–≤–µ—Ç–∞: " . round($responseTime, 2) . "ms");
                if ($responseTime > 5000) {
                    $this->warn('    ‚ö†Ô∏è  –ú–µ–¥–ª–µ–Ω–Ω—ã–π –æ—Ç–≤–µ—Ç (>5—Å)');
                }
            }
            
        } catch (\Exception $e) {
            $this->error("    ‚ùå –û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è: {$e->getMessage()}");
        }
    }
} 